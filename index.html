<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test d'Orthographe Fran√ßaise</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        h1 {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .start-section {
            margin-bottom: 30px;
        }

        select,
        input,
        button {
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .score {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
        }

        .question-info {
            font-size: 1.2rem;
            color: #4a5568;
            margin-bottom: 20px;
        }

        .input-section {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .word-input {
            min-width: 300px;
            font-size: 18px;
        }

        .replay-btn {
            background: #48bb78;
            padding: 12px 20px;
        }

        .replay-btn:hover {
            background: #38a169;
        }

        .feedback-container {
            height: 80px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result {
            padding: 15px;
            border-radius: 12px;
            font-weight: 600;
            animation: slideInFade 3s ease-in-out;
            width: 100%;
        }

        @keyframes slideInFade {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            10% {
                opacity: 1;
                transform: translateX(0);
            }

            90% {
                opacity: 1;
                transform: translateX(0);
            }

            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        .correct {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }

        .incorrect {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #e53e3e;
        }

        .leaderboard {
            margin-top: 30px;
            text-align: left;
        }

        .leaderboard h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #4a5568;
        }

        .leaderboard-entry {
            background: #f7fafc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .leaderboard-info {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .error-count {
            color: #e53e3e;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .view-errors-btn {
            background: #ed8936;
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .view-errors-btn:hover {
            background: #dd6b20;
            transform: translateY(-1px);
        }

        .view-errors-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .errors-section {
            margin-top: 15px;
            padding: 15px;
            background: #fed7d7;
            border-radius: 8px;
            border: 1px solid #e53e3e;
            animation: expandIn 0.3s ease-out;
        }

        @keyframes expandIn {
            0% {
                opacity: 0;
                max-height: 0;
            }

            100% {
                opacity: 1;
                max-height: 500px;
            }
        }

        .errors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #e53e3e;
            padding-bottom: 8px;
        }

        .errors-title {
            font-weight: 600;
            color: #742a2a;
            font-size: 14px;
        }

        .close-errors-btn {
            background: transparent;
            color: #742a2a;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            margin: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .close-errors-btn:hover {
            background: rgba(116, 42, 42, 0.1);
            transform: none;
            box-shadow: none;
        }

        .error-item {
            margin: 8px 0;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #e53e3e;
        }

        .error-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .error-question {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .error-comparison {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .correct-word {
            color: #22543d;
            font-weight: 600;
            background: #c6f6d5;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .user-word {
            color: #742a2a;
            font-weight: 600;
            background: #fed7d7;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            text-decoration: line-through;
        }

        .replay-error-btn {
            background: #48bb78;
            color: white;
            border: none;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .replay-error-btn:hover {
            background: #38a169;
            transform: translateY(-1px);
        }

        .difficulty-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .easy {
            background: #c6f6d5;
            color: #22543d;
        }

        .medium {
            background: #feebc8;
            color: #744210;
        }

        .hard {
            background: #fed7d7;
            color: #742a2a;
        }

        .clear-data-btn {
            background: #e53e3e;
            font-size: 12px;
            padding: 8px 16px;
            margin-top: 10px;
        }

        .clear-data-btn:hover {
            background: #c53030;
        }

        .no-errors {
            text-align: center;
            color: #22543d;
            font-style: italic;
            padding: 10px;
        }

        /* Voice Selection Styles */
        .voice-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .voice-section h4 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .voice-select {
            min-width: 250px;
            max-width: 350px;
            font-size: 14px;
            padding: 10px 15px;
        }

        .voice-test-btn {
            background: #48bb78;
            padding: 10px 15px;
            font-size: 14px;
            text-transform: none;
            letter-spacing: 0;
        }

        .voice-test-btn:hover {
            background: #38a169;
        }

        .voice-test-btn:disabled {
            background: #cbd5e0;
        }

        .voice-status {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const WORDS = {
            facile: [
                // Basic everyday words (150 words)
                'chat', 'chien', 'maison', '√©cole', 'livre', 'table', 'chaise', 'porte', 'fen√™tre', 'jardin',
                'voiture', 'train', 'avion', 'bateau', 'v√©lo', 'rouge', 'bleu', 'vert', 'jaune', 'noir',
                'blanc', 'manger', 'boire', 'dormir', 'jouer', 'courir', 'marcher', '√©crire', 'lire', 'parler',
                'famille', 'p√®re', 'm√®re', 'enfant', 'fr√®re', 'soeur', 'grand', 'petit', 'beau', 'laid',
                'chaud', 'froid', 'jour', 'nuit', 'matin', 'soir', 'eau', 'pain', 'lait', 'fromage',
                'viande', 'l√©gume', 'fruit', 'pomme', 'orange', 'banane', 'carotte', 'tomate', 'salade', 'oignon',
                't√™te', 'bras', 'jambe', 'main', 'pied', 'oeil', 'nez', 'bouche', 'oreille', 'cheveu',
                'chemise', 'pantalon', 'robe', 'chaussure', 'chapeau', 'manteau', 'veste', 'short', 'jupe', 'pull',
                'ami', 'amie', 'copain', 'voisin', 'm√©decin', 'professeur', '√©l√®ve', 'boulanger', 'coiffeur', 'fermier',
                'arbre', 'fleur', 'herbe', 'feuille', 'branche', 'racine', 'soleil', 'lune', '√©toile', 'nuage',
                'pluie', 'neige', 'vent', 'mer', 'lac', 'rivi√®re', 'montagne', 'for√™t', 'plage', 'd√©sert',
                'ville', 'village', 'rue', 'route', 'pont', '√©glise', 'h√¥pital', 'magasin', 'restaurant', 'caf√©',
                'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche', 'janvier', 'f√©vrier', 'mars',
                'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre', 'ann√©e',
                'heure', 'minute', 'seconde', 'semaine', 'mois', 'hier', 'aujourd', 'demain', 'maintenant', 'bient√¥t'
            ],
            moyen: [
                // Intermediate words (150 words)
                'acqu√©rir', 'd√©velopper', 'excellent', 'fasciner', 'gouvernement', 'hypoth√®se', 'intelligent', 'joaillerie', 'kermesse', 'lymphatique',
                'magnifique', 'n√©cessaire', 'obscurit√©', 'psychiatre', 'quarantaine', 'rhododendron', 'sympathique', 'th√©√¢tre', 'philosophie', 'g√©ographie',
                'math√©matiques', 'physique', 'chimie', 'biologie', 'psychologie', 'rythme', 'gymnastique', 'orthographe', 'grammaire', 'vocabulaire',
                'dictionnaire', 'encyclop√©die', 'biblioth√®que', 'universit√©', 'professeur', '√©tudiant', 'exercice', 'probl√®me', 'solution', 'explication',
                'temp√©rature', 'atmosph√®re', 'respiration', 'circulation', 'digestion', 'alimentation', '√©quilibre', 'hygi√®ne', 'sant√©', 'maladie',
                'm√©dicament', 'traitement', 'gu√©rison', 'pr√©vention', 'vaccination', 'consultation', 'diagnostic', 'sympt√¥me', 'fi√®vre', 'douleur',
                'fatigue', 'stress', 'anxi√©t√©', 'bonheur', 'tristesse', 'col√®re', 'peur', 'courage', 'patience', 'g√©n√©rosit√©',
                'politesse', 'respect', 'tol√©rance', 'justice', 'libert√©', '√©galit√©', 'fraternit√©', 'd√©mocratie', 'r√©publique', '√©lection',
                'pr√©sident', 'ministre', 'd√©put√©', 'maire', 'conseil', 'assembl√©e', 'parlement', 'constitution', 'citoyen', 'civisme',
                'technologie', 'ordinateur', 'internet', 'logiciel', 'programme', 'syst√®me', 'r√©seau', 'connexion', 'application', 'interface',
                '√©conomie', 'commerce', 'industrie', 'agriculture', 'banque', 'monnaie', 'budget', 'd√©pense', 'revenu', 'imp√¥t',
                'transport', 'communication', 'information', 'journalisme', 't√©l√©vision', 'radio', 'journal', 'magazine', 'publicit√©', 'culture',
                'tradition', 'coutume', 'festival', 'c√©l√©bration', 'anniversaire', 'mariage', 'bapt√™me', 'communion', 'confirmation', 'fun√©railles',
                'musique', 'chanson', 'instrument', 'orchestre', 'concert', 'danse', 'ballet', 'op√©ra', 'com√©die', 'trag√©die',
                'peinture', 'sculpture', 'architecture', 'litt√©rature', 'po√©sie', 'roman', 'nouvelle', 'essai', 'biographie', 'histoire'
            ],
            difficile: [
                // Advanced words (150 words)
                'anticonstitutionnellement', 'concupiscence', 'dithyrambique', 'ecchymose', 'flibustier', 'gyn√©cologue', 'hippopotame', 'ichtyologie', 'jalousement', 'kin√©sith√©rapeute',
                'labyrinthique', 'mn√©motechnique', 'nomenclature', '≈ìcum√©nique', 'psychanalyse', 'quincaillerie', 'rhumatisme', 'st√©thoscope', 'tyrannosaure', 'xylophone',
                'chrysanth√®me', 'an√©mone', 'bougainvill√©e', 'dahlia', 'forsythia', 'glycine', 'hortensia', 'jacinthe', 'magnolia', 'narcisse',
                'orchid√©e', 'pivoine', 'tulipe', 'zinnia', 'phytoth√©rapie', 'hom√©opathie', 'acupuncture', 'ost√©opathie', 'chiropraxie', 'naturopathie',
                'aromath√©rapie', 'r√©flexologie', 'psychoth√©rapie', 'neurologie', 'cardiologie', 'dermatologie', 'ophtalmologie', 'otorhinolaryngologie', 'gastroent√©rologie', 'pneumologie',
                'rhumatologie', 'endocrinologie', 'h√©matologie', 'oncologie', 'g√©riatrie', 'p√©diatrie', 'psychiatrie', 'radiologie', 'anesth√©siologie', 'chirurgie',
                'gyn√©cologie', 'urologie', 'orthop√©die', 'traumatologie', 'pharmacologie', 'toxicologie', '√©pid√©miologie', 'microbiologie', 'immunologie', 'g√©n√©tique',
                'biotechnologie', 'nanotechnologie', 'cybern√©tique', 'informatique', '√©lectronique', 'm√©canique', 'hydraulique', 'pneumatique', 'thermodynamique', '√©lectromagn√©tisme',
                'radioactivit√©', 'spectroscopie', 'chromatographie', 'crystallographie', 'm√©tallurgie', 'p√©trochimie', '√©pist√©mologie', 'ph√©nom√©nologie', 'herm√©neutique', 'dialectique',
                'rh√©torique', 's√©miotique', 'linguistique', 'phon√©tique', 'morphologie', 'syntaxe', 's√©mantique', 'pragmatique', 'sociolinguistique', 'psycholinguistique',
                'anthropologie', 'arch√©ologie', 'ethnologie', 'sociologie', 'criminologie', 'victimologie', 'p√©nologie', 'd√©ontologie', 'axiologie', 't√©l√©ologie',
                'eschatologie', 'sot√©riologie', 'christologie', 'eccl√©siologie', 'mariologie', 'pneumatologie', 'patristique', 'scholastique', 'thomisme', 'augustinisme',
                'n√©oplatonisme', 'aristot√©lisme', 'cart√©sianisme', 'spinozisme', 'leibnizianisme', 'kantisme', 'h√©g√©lianisme', 'schopenhaurisme', 'nietzsch√©isme', 'existentialisme',
                'ph√©nom√©nologie', 'structuralisme', 'poststructuralisme', 'd√©constructionnisme', 'postmodernisme', 'n√©olib√©ralisme', 'social-d√©mocratie', 'anarcho-syndicalisme', 'crypto-anarchisme',
                'transhumanisme', 'posthumanisme', 'bioconservatisme', '√©cofascisme', '√©cof√©minisme', 'biodynamique', 'permaculture', 'agro√©cologie', 'sylviculture', 'aquaculture'
            ]
        };

        // LocalStorage utility functions
        const STORAGE_KEYS = {
            LEADERBOARD: 'french-spelling-leaderboard',
            ERROR_HISTORY: 'french-spelling-error-history',
            GAME_STATE: 'french-spelling-game-state',
            USER_PREFERENCES: 'french-spelling-preferences',
            SELECTED_VOICE: 'french-spelling-selected-voice'
        };

        const saveToStorage = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (error) {
                console.warn('Failed to save to localStorage:', error);
            }
        };

        const loadFromStorage = (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
                return defaultValue;
            }
        };

        const clearStorage = (key) => {
            try {
                localStorage.removeItem(key);
            } catch (error) {
                console.warn('Failed to clear localStorage:', error);
            }
        };

        // Generate unique game ID
        const generateGameId = () => {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        };

        function SpellingGame() {
            const [gameState, setGameState] = useState('start');
            const [difficulty, setDifficulty] = useState('facile');
            const [currentQuestion, setCurrentQuestion] = useState(0);
            const [score, setScore] = useState(0);
            const [gameWords, setGameWords] = useState([]);
            const [userInput, setUserInput] = useState('');
            const [feedback, setFeedback] = useState('');
            const [leaderboard, setLeaderboard] = useState([]);
            const [currentGameId, setCurrentGameId] = useState(null);
            const [currentGameErrors, setCurrentGameErrors] = useState([]);
            const [expandedErrors, setExpandedErrors] = useState({});
            
            // Voice selection states
            const [availableVoices, setAvailableVoices] = useState([]);
            const [selectedVoice, setSelectedVoice] = useState(null);
            const [voicesLoaded, setVoicesLoaded] = useState(false);

            // Load voices and set default French voice
            const loadVoices = () => {
                if ('speechSynthesis' in window) {
                    const voices = window.speechSynthesis.getVoices();
                    setAvailableVoices(voices);
                    setVoicesLoaded(true);

                    // Load saved voice preference or set default French voice
                    const savedVoice = loadFromStorage(STORAGE_KEYS.SELECTED_VOICE);
                    
                    if (savedVoice && voices.find(v => v.name === savedVoice.name && v.lang === savedVoice.lang)) {
                        const voice = voices.find(v => v.name === savedVoice.name && v.lang === savedVoice.lang);
                        setSelectedVoice(voice);
                    } else {
                        // Find default French voice
                        const frenchVoice = voices.find(voice =>
                            voice.lang === 'fr-FR' ||
                            voice.lang === 'fr' ||
                            voice.name.toLowerCase().includes('french') ||
                            voice.name.toLowerCase().includes('fran√ßais')
                        );
                        
                        if (frenchVoice) {
                            setSelectedVoice(frenchVoice);
                            saveToStorage(STORAGE_KEYS.SELECTED_VOICE, {
                                name: frenchVoice.name,
                                lang: frenchVoice.lang
                            });
                        }
                    }
                }
            };

            // Initialize voices
            useEffect(() => {
                if ('speechSynthesis' in window) {
                    // Handle voices loading asynchronously
                    window.speechSynthesis.onvoiceschanged = loadVoices;
                    // Also call immediately in case voices are already loaded
                    loadVoices();
                    setTimeout(loadVoices, 1000);
                }
            }, []);

            // Handle voice selection
            const handleVoiceChange = (voiceName) => {
                const voice = availableVoices.find(v => v.name === voiceName);
                if (voice) {
                    setSelectedVoice(voice);
                    saveToStorage(STORAGE_KEYS.SELECTED_VOICE, {
                        name: voice.name,
                        lang: voice.lang
                    });
                }
            };

            // Test voice functionality
            const testVoice = () => {
                if (selectedVoice) {
                    speakWord('Bonjour');
                }
            };

            // Load data from localStorage on component mount
            useEffect(() => {
                const savedLeaderboard = loadFromStorage(STORAGE_KEYS.LEADERBOARD, []);
                const savedPreferences = loadFromStorage(STORAGE_KEYS.USER_PREFERENCES, {});

                setLeaderboard(savedLeaderboard);

                // Restore user preferences
                if (savedPreferences.difficulty) {
                    setDifficulty(savedPreferences.difficulty);
                }

                // Check for interrupted game
                const savedGameState = loadFromStorage(STORAGE_KEYS.GAME_STATE);
                if (savedGameState && savedGameState.gameState === 'playing') {
                    // Ask user if they want to continue
                    const continueGame = window.confirm('Vous avez une partie en cours. Voulez-vous la continuer?');
                    if (continueGame) {
                        setGameState(savedGameState.gameState);
                        setDifficulty(savedGameState.difficulty);
                        setCurrentQuestion(savedGameState.currentQuestion);
                        setScore(savedGameState.score);
                        setGameWords(savedGameState.gameWords);
                        setCurrentGameId(savedGameState.currentGameId);
                        setCurrentGameErrors(savedGameState.currentGameErrors || []);
                        setUserInput('');
                        setFeedback('');

                        // Speak the current word
                        setTimeout(() => {
                            speakWord(savedGameState.gameWords[savedGameState.currentQuestion]);
                        }, 500);
                    } else {
                        clearStorage(STORAGE_KEYS.GAME_STATE);
                    }
                }
            }, []);

            // Save leaderboard to localStorage whenever it changes
            useEffect(() => {
                if (leaderboard.length > 0) {
                    saveToStorage(STORAGE_KEYS.LEADERBOARD, leaderboard);
                }
            }, [leaderboard]);

            // Save user preferences
            useEffect(() => {
                saveToStorage(STORAGE_KEYS.USER_PREFERENCES, { difficulty });
            }, [difficulty]);

            // Save game state during gameplay
            useEffect(() => {
                if (gameState === 'playing') {
                    const gameStateData = {
                        gameState,
                        difficulty,
                        currentQuestion,
                        score,
                        gameWords,
                        currentGameId,
                        currentGameErrors
                    };
                    saveToStorage(STORAGE_KEYS.GAME_STATE, gameStateData);
                } else {
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                }
            }, [gameState, difficulty, currentQuestion, score, gameWords, currentGameId, currentGameErrors]);

            const speakWord = (word) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(word);

                    // Use selected voice if available
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                        utterance.lang = selectedVoice.lang;
                    } else {
                        // Fallback to setting language without specific voice
                        utterance.lang = 'fr-FR';
                    }

                    utterance.rate = 0.8;
                    utterance.pitch = 1.0;

                    window.speechSynthesis.speak(utterance);
                }
            };

            const startGame = () => {
                const wordList = WORDS[difficulty];
                const selectedWords = wordList.sort(() => 0.5 - Math.random()).slice(0, 10);
                const newGameId = generateGameId();

                setGameWords(selectedWords);
                setCurrentQuestion(0);
                setScore(0);
                setUserInput('');
                setFeedback('');
                setCurrentGameId(newGameId);
                setCurrentGameErrors([]);
                setGameState('playing');

                // Speak first word after a short delay
                setTimeout(() => {
                    speakWord(selectedWords[0]);
                }, 500);
            };

            const submitAnswer = () => {
                const currentWord = gameWords[currentQuestion];
                const isCorrect = userInput.toLowerCase().trim() === currentWord.toLowerCase();

                let newScore = score;
                if (isCorrect) {
                    newScore = score + 1;
                    setScore(newScore);
                } else {
                    // Track error
                    const errorEntry = {
                        gameId: currentGameId,
                        timestamp: Date.now(),
                        word: currentWord,
                        userInput: userInput.trim(),
                        difficulty: difficulty,
                        questionNumber: currentQuestion + 1
                    };

                    // Add to current game errors
                    const newGameErrors = [...currentGameErrors, errorEntry];
                    setCurrentGameErrors(newGameErrors);

                    // Add to error history
                    const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                    errorHistory.push(errorEntry);
                    saveToStorage(STORAGE_KEYS.ERROR_HISTORY, errorHistory);
                }

                // Set feedback for previous answer
                const feedbackMessage = isCorrect
                    ? `‚úÖ Correct! Le mot √©tait: ${currentWord}`
                    : `‚ùå Incorrect. Le mot √©tait: ${currentWord} (vous avez √©crit: ${userInput})`;

                setFeedback(feedbackMessage);

                // Immediately transition to next question or finish game
                if (currentQuestion < 9) {
                    setCurrentQuestion(currentQuestion + 1);
                    setUserInput('');
                    // Speak next word immediately
                    setTimeout(() => {
                        speakWord(gameWords[currentQuestion + 1]);
                    }, 100);

                    // Clear feedback after showing it briefly
                    setTimeout(() => {
                        setFeedback('');
                    }, 3000);
                } else {
                    // Clear feedback and finish game after brief delay
                    setTimeout(() => {
                        setFeedback('');
                        finishGame(newScore);
                    }, 2000);
                }
            };

            const finishGame = (finalScore = score) => {
                const gameResult = {
                    id: currentGameId,
                    date: new Date().toLocaleDateString('fr-FR'),
                    time: new Date().toLocaleTimeString('fr-FR'),
                    score: finalScore,
                    difficulty: difficulty,
                    timestamp: Date.now(),
                    errorCount: currentGameErrors.length
                };

                const newLeaderboard = [...leaderboard, gameResult]
                    .sort((a, b) => {
                        // Sort by score first, then by timestamp for ties
                        if (b.score !== a.score) return b.score - a.score;
                        return b.timestamp - a.timestamp;
                    })
                    .slice(0, 10);

                setLeaderboard(newLeaderboard);
                setGameState('finished');
            };

            const resetGame = () => {
                setGameState('start');
                setUserInput('');
                setFeedback('');
                setCurrentGameId(null);
                setCurrentGameErrors([]);
                clearStorage(STORAGE_KEYS.GAME_STATE);
            };

            const clearAllData = () => {
                const confirmClear = window.confirm('√ätes-vous s√ªr de vouloir effacer toutes les donn√©es sauvegard√©es?');
                if (confirmClear) {
                    clearStorage(STORAGE_KEYS.LEADERBOARD);
                    clearStorage(STORAGE_KEYS.ERROR_HISTORY);
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                    clearStorage(STORAGE_KEYS.USER_PREFERENCES);
                    clearStorage(STORAGE_KEYS.SELECTED_VOICE);
                    setLeaderboard([]);
                    setDifficulty('facile');
                    alert('Toutes les donn√©es ont √©t√© effac√©es!');
                }
            };

            // Get errors for a specific game
            const getErrorsForGame = (gameId) => {
                const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                return errorHistory.filter(error => error.gameId === gameId);
            };

            // Toggle error display
            const toggleErrorDisplay = (gameId) => {
                setExpandedErrors(prev => ({
                    ...prev,
                    [gameId]: !prev[gameId]
                }));
            };

            // Error display component
            const ErrorDisplay = ({ gameId }) => {
                const errors = getErrorsForGame(gameId);

                if (errors.length === 0) {
                    return (
                        <div className="errors-section">
                            <div className="errors-header">
                                <span className="errors-title">‚ùå Erreurs de cette partie</span>
                                <button
                                    className="close-errors-btn"
                                    onClick={() => toggleErrorDisplay(gameId)}
                                >
                                    √ó
                                </button>
                            </div>
                            <div className="no-errors">Aucune erreur dans cette partie! üéâ</div>
                        </div>
                    );
                }

                return (
                    <div className="errors-section">
                        <div className="errors-header">
                            <span className="errors-title">‚ùå Erreurs de cette partie ({errors.length})</span>
                            <button
                                className="close-errors-btn"
                                onClick={() => toggleErrorDisplay(gameId)}
                            >
                                √ó
                            </button>
                        </div>
                        {errors.map((error, index) => (
                            <div key={index} className="error-item">
                                <div className="error-details">
                                    <div className="error-question">Question {error.questionNumber}/10</div>
                                    <div className="error-comparison">
                                        <span>Correct:</span>
                                        <span className="correct-word">{error.word}</span>
                                        <span>Votre r√©ponse:</span>
                                        <span className="user-word">{error.userInput}</span>
                                        <button
                                            className="replay-error-btn"
                                            onClick={() => speakWord(error.word)}
                                        >
                                            üîä √âcouter
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && userInput.trim()) {
                    submitAnswer();
                }
            };

            // Voice Selection Component
            const VoiceSelector = () => {
                if (!('speechSynthesis' in window)) {
                    return (
                        <div className="voice-section">
                            <h4>üîä S√©lection de la voix</h4>
                            <div className="voice-status">
                                Speech Synthesis API n'est pas support√© dans ce navigateur.
                            </div>
                        </div>
                    );
                }

                return (
                    <div className="voice-section">
                        <h4>üîä S√©lection de la voix</h4>
                        <div className="voice-controls">
                            <select
                                className="voice-select"
                                value={selectedVoice?.name || ''}
                                onChange={(e) => handleVoiceChange(e.target.value)}
                                disabled={!voicesLoaded || availableVoices.length === 0}
                            >
                                <option value="">
                                    {voicesLoaded ? 'S√©lectionnez une voix...' : 'Chargement des voix...'}
                                </option>
                                {availableVoices.map((voice, index) => (
                                    <option key={index} value={voice.name}>
                                        {voice.name} ({voice.lang})
                                        {voice.lang.startsWith('fr') ? ' üá´üá∑' : ''}
                                        {voice.default ? ' [d√©faut]' : ''}
                                    </option>
                                ))}
                            </select>
                            <button
                                className="voice-test-btn"
                                onClick={testVoice}
                                disabled={!selectedVoice}
                            >
                                üîä Tester
                            </button>
                        </div>
                        {selectedVoice && (
                            <div className="voice-status">
                                Voix s√©lectionn√©e: {selectedVoice.name} ({selectedVoice.lang})
                            </div>
                        )}
                    </div>
                );
            };

            if (gameState === 'start') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>Test d'Orthographe</h1>
                            <div className="start-section">
                                <div>
                                    <label htmlFor="difficulty">Choisissez la difficult√©:</label>
                                    <select
                                        id="difficulty"
                                        value={difficulty}
                                        onChange={(e) => setDifficulty(e.target.value)}
                                    >
                                        <option value="facile">Facile</option>
                                        <option value="moyen">Moyen</option>
                                        <option value="difficile">Difficile</option>
                                    </select>
                                </div>
                                <button onClick={startGame}>Commencer le Jeu</button>
                            </div>

                            <VoiceSelector />

                            {leaderboard.length > 0 && (
                                <div className="leaderboard">
                                    <h3>üèÜ Tableau des Scores</h3>
                                    {leaderboard.map((entry, index) => (
                                        <div key={index} className="leaderboard-entry">
                                            <div className="leaderboard-header">
                                                <div className="leaderboard-info">
                                                    <span>{entry.date} {entry.time}</span>
                                                    <span className={`difficulty-badge ${entry.difficulty}`}>
                                                        {entry.difficulty}
                                                    </span>
                                                    <span><strong>{entry.score}/10</strong></span>
                                                    {entry.errorCount > 0 && (
                                                        <span className="error-count">
                                                            ({entry.errorCount} erreur{entry.errorCount > 1 ? 's' : ''})
                                                        </span>
                                                    )}
                                                </div>
                                                {entry.id && (
                                                    <button
                                                        className="view-errors-btn"
                                                        onClick={() => toggleErrorDisplay(entry.id)}
                                                    >
                                                        üìù Voir erreurs
                                                    </button>
                                                )}
                                            </div>
                                            {expandedErrors[entry.id] && entry.id && (
                                                <ErrorDisplay gameId={entry.id} />
                                            )}
                                        </div>
                                    ))}
                                    <button
                                        className="clear-data-btn"
                                        onClick={clearAllData}
                                    >
                                        Effacer toutes les donn√©es
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (gameState === 'playing') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <div className="score">Score: {score}/{currentQuestion}</div>
                            <div className="question-info">
                                Question {currentQuestion + 1}/10 - Difficult√©: {difficulty}
                                {currentGameErrors.length > 0 && (
                                    <div className="error-count">
                                        {currentGameErrors.length} erreur{currentGameErrors.length > 1 ? 's' : ''} jusqu'ici
                                    </div>
                                )}
                            </div>

                            <div className="game-section">
                                <button
                                    className="replay-btn"
                                    onClick={() => speakWord(gameWords[currentQuestion])}
                                >
                                    üîä R√©p√©ter le mot
                                </button>

                                <div className="input-section">
                                    <input
                                        type="text"
                                        className="word-input"
                                        value={userInput}
                                        onChange={(e) => setUserInput(e.target.value)}
                                        onKeyPress={handleKeyPress}
                                        placeholder="Tapez le mot que vous entendez..."
                                        autoFocus
                                    />
                                    <button
                                        onClick={submitAnswer}
                                        disabled={!userInput.trim()}
                                    >
                                        Valider
                                    </button>
                                </div>

                                <div className="feedback-container">
                                    {feedback && (
                                        <div className={`result ${feedback.includes('‚úÖ') ? 'correct' : 'incorrect'}`}>
                                            {feedback}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'finished') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>Jeu Termin√©!</h1>
                            <div className="score">Score final: {score}/10</div>
                            <div className="question-info">
                                Difficult√©: {difficulty}
                                {currentGameErrors.length > 0 && (
                                    <div className="error-count">
                                        {currentGameErrors.length} erreur{currentGameErrors.length > 1 ? 's' : ''} au total
                                    </div>
                                )}
                            </div>

                            {currentGameErrors.length > 0 && (
                                <div style={{ marginTop: '20px' }}>
                                    <button
                                        className="view-errors-btn"
                                        onClick={() => toggleErrorDisplay(currentGameId)}
                                    >
                                        üìù Voir les erreurs de cette partie
                                    </button>
                                    {expandedErrors[currentGameId] && (
                                        <ErrorDisplay gameId={currentGameId} />
                                    )}
                                </div>
                            )}

                            <button onClick={resetGame} style={{ marginTop: '20px' }}>
                                Nouvelle Partie
                            </button>

                            {leaderboard.length > 0 && (
                                <div className="leaderboard">
                                    <h3>üèÜ Tableau des Scores</h3>
                                    {leaderboard.map((entry, index) => (
                                        <div key={index} className="leaderboard-entry">
                                            <div className="leaderboard-header">
                                                <div className="leaderboard-info">
                                                    <span>{entry.date} {entry.time}</span>
                                                    <span className={`difficulty-badge ${entry.difficulty}`}>
                                                        {entry.difficulty}
                                                    </span>
                                                    <span><strong>{entry.score}/10</strong></span>
                                                    {entry.errorCount > 0 && (
                                                        <span className="error-count">
                                                            ({entry.errorCount} erreur{entry.errorCount > 1 ? 's' : ''})
                                                        </span>
                                                    )}
                                                </div>
                                                {entry.id && (
                                                    <button
                                                        className="view-errors-btn"
                                                        onClick={() => toggleErrorDisplay(entry.id)}
                                                    >
                                                        üìù Voir erreurs
                                                    </button>
                                                )}
                                            </div>
                                            {expandedErrors[entry.id] && entry.id && (
                                                <ErrorDisplay gameId={entry.id} />
                                            )}
                                        </div>
                                    ))}
                                    <button
                                        className="clear-data-btn"
                                        onClick={clearAllData}
                                    >
                                        Effacer toutes les donn√©es
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }
        }

        // Render the main game component
        ReactDOM.render(<SpellingGame />, document.getElementById('root'));
    </script>
</body>

</html>