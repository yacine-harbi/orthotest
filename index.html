<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test d'Orthographe Fran√ßaise</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        h1 {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .start-section {
            margin-bottom: 30px;
        }

        select,
        input,
        button {
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .score {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
        }

        .question-info {
            font-size: 1.2rem;
            color: #4a5568;
            margin-bottom: 20px;
        }

        .input-section {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .word-input {
            min-width: 300px;
            font-size: 18px;
        }

        .replay-btn {
            background: #48bb78;
            padding: 12px 20px;
        }

        .replay-btn:hover {
            background: #38a169;
        }

        .feedback-container {
            height: 80px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result {
            padding: 15px;
            border-radius: 12px;
            font-weight: 600;
            animation: slideInFade 3s ease-in-out;
            width: 100%;
        }

        @keyframes slideInFade {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            10% {
                opacity: 1;
                transform: translateX(0);
            }

            90% {
                opacity: 1;
                transform: translateX(0);
            }

            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        .correct {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }

        .incorrect {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #e53e3e;
        }

        .leaderboard {
            margin-top: 30px;
            text-align: left;
        }

        .leaderboard h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #4a5568;
        }

        .leaderboard-entry {
            background: #f7fafc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .leaderboard-info {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .error-count {
            color: #e53e3e;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .view-errors-btn {
            background: #ed8936;
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .view-errors-btn:hover {
            background: #dd6b20;
            transform: translateY(-1px);
        }

        .view-errors-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .errors-section {
            margin-top: 15px;
            padding: 15px;
            background: #fed7d7;
            border-radius: 8px;
            border: 1px solid #e53e3e;
            animation: expandIn 0.3s ease-out;
        }

        @keyframes expandIn {
            0% {
                opacity: 0;
                max-height: 0;
            }

            100% {
                opacity: 1;
                max-height: 500px;
            }
        }

        .errors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #e53e3e;
            padding-bottom: 8px;
        }

        .errors-title {
            font-weight: 600;
            color: #742a2a;
            font-size: 14px;
        }

        .close-errors-btn {
            background: transparent;
            color: #742a2a;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            margin: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .close-errors-btn:hover {
            background: rgba(116, 42, 42, 0.1);
            transform: none;
            box-shadow: none;
        }

        .error-item {
            margin: 8px 0;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #e53e3e;
        }

        .error-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .error-question {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .error-comparison {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .correct-word {
            color: #22543d;
            font-weight: 600;
            background: #c6f6d5;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .user-word {
            color: #742a2a;
            font-weight: 600;
            background: #fed7d7;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            text-decoration: line-through;
        }

        .replay-error-btn {
            background: #48bb78;
            color: white;
            border: none;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .replay-error-btn:hover {
            background: #38a169;
            transform: translateY(-1px);
        }

        .difficulty-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .easy {
            background: #c6f6d5;
            color: #22543d;
        }

        .medium {
            background: #feebc8;
            color: #744210;
        }

        .hard {
            background: #fed7d7;
            color: #742a2a;
        }

        .clear-data-btn {
            background: #e53e3e;
            font-size: 12px;
            padding: 8px 16px;
            margin-top: 10px;
        }

        .clear-data-btn:hover {
            background: #c53030;
        }

        .no-errors {
            text-align: center;
            color: #22543d;
            font-style: italic;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const WORDS = {
            facile: [
                'chat', 'chien', 'maison', '√©cole', 'livre',
                'table', 'chaise', 'porte', 'fen√™tre', 'jardin',
                'voiture', 'train', 'avion', 'bateau', 'v√©lo',
                'rouge', 'bleu', 'vert', 'jaune', 'noir'
            ],
            moyen: [
                'abhorrer', 'acqu√©rir', 'butterfly', 'chrysanth√®me', 'd√©velopper',
                'excellent', 'fasciner', 'gouvernement', 'hypoth√®se', 'intelligent',
                'joaillerie', 'kermesse', 'lymphatique', 'magnifique', 'n√©cessaire',
                'obscurit√©', 'psychiatre', 'quarantaine', 'rhododendron', 'sympathique'
            ],
            difficile: [
                'concupiscence', 'anticonstitutionnellement', 'chrysanth√®me', 'dithyrambique', 'ecchymose',
                'flibustier', 'gyn√©cologue', 'hippopotame', 'ichtyologie', 'jalousement',
                'kin√©sith√©rapeute', 'labyrinthique', 'mnemotechnique', 'nomenclature', 'oecum√©nique',
                'psychanalyse', 'quincaillerie', 'rhumatisme', 'st√©thoscope', 'tyrannosaure'
            ]
        };

        // LocalStorage utility functions
        const STORAGE_KEYS = {
            LEADERBOARD: 'french-spelling-leaderboard',
            ERROR_HISTORY: 'french-spelling-error-history', // NEW
            GAME_STATE: 'french-spelling-game-state',
            USER_PREFERENCES: 'french-spelling-preferences'
        };

        const saveToStorage = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (error) {
                console.warn('Failed to save to localStorage:', error);
            }
        };

        const loadFromStorage = (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
                return defaultValue;
            }
        };

        const clearStorage = (key) => {
            try {
                localStorage.removeItem(key);
            } catch (error) {
                console.warn('Failed to clear localStorage:', error);
            }
        };

        // Generate unique game ID
        const generateGameId = () => {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        };

        function SpellingGame() {
            const [gameState, setGameState] = useState('start');
            const [difficulty, setDifficulty] = useState('facile');
            const [currentQuestion, setCurrentQuestion] = useState(0);
            const [score, setScore] = useState(0);
            const [gameWords, setGameWords] = useState([]);
            const [userInput, setUserInput] = useState('');
            const [feedback, setFeedback] = useState('');
            const [leaderboard, setLeaderboard] = useState([]);
            const [currentGameId, setCurrentGameId] = useState(null); // NEW
            const [currentGameErrors, setCurrentGameErrors] = useState([]); // NEW
            const [expandedErrors, setExpandedErrors] = useState({}); // NEW

            // Load data from localStorage on component mount
            useEffect(() => {
                const savedLeaderboard = loadFromStorage(STORAGE_KEYS.LEADERBOARD, []);
                const savedPreferences = loadFromStorage(STORAGE_KEYS.USER_PREFERENCES, {});

                setLeaderboard(savedLeaderboard);

                // Restore user preferences
                if (savedPreferences.difficulty) {
                    setDifficulty(savedPreferences.difficulty);
                }

                // Check for interrupted game
                const savedGameState = loadFromStorage(STORAGE_KEYS.GAME_STATE);
                if (savedGameState && savedGameState.gameState === 'playing') {
                    // Ask user if they want to continue
                    const continueGame = window.confirm('Vous avez une partie en cours. Voulez-vous la continuer?');
                    if (continueGame) {
                        setGameState(savedGameState.gameState);
                        setDifficulty(savedGameState.difficulty);
                        setCurrentQuestion(savedGameState.currentQuestion);
                        setScore(savedGameState.score);
                        setGameWords(savedGameState.gameWords);
                        setCurrentGameId(savedGameState.currentGameId); // NEW
                        setCurrentGameErrors(savedGameState.currentGameErrors || []); // NEW
                        setUserInput('');
                        setFeedback('');

                        // Speak the current word
                        setTimeout(() => {
                            speakWord(savedGameState.gameWords[savedGameState.currentQuestion]);
                        }, 500);
                    } else {
                        clearStorage(STORAGE_KEYS.GAME_STATE);
                    }
                }
            }, []);

            // Save leaderboard to localStorage whenever it changes
            useEffect(() => {
                if (leaderboard.length > 0) {
                    saveToStorage(STORAGE_KEYS.LEADERBOARD, leaderboard);
                }
            }, [leaderboard]);

            // Save user preferences
            useEffect(() => {
                saveToStorage(STORAGE_KEYS.USER_PREFERENCES, { difficulty });
            }, [difficulty]);

            // Save game state during gameplay
            useEffect(() => {
                if (gameState === 'playing') {
                    const gameStateData = {
                        gameState,
                        difficulty,
                        currentQuestion,
                        score,
                        gameWords,
                        currentGameId, // NEW
                        currentGameErrors // NEW
                    };
                    saveToStorage(STORAGE_KEYS.GAME_STATE, gameStateData);
                } else {
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                }
            }, [gameState, difficulty, currentQuestion, score, gameWords, currentGameId, currentGameErrors]);

            const speakWord = (word) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(word);

                    // Get available voices
                    const voices = window.speechSynthesis.getVoices();

                    // Try to find a French voice (prioritize different French variants)
                    const frenchVoice = voices.find(voice =>
                        voice.lang === 'fr-FR' ||
                        //voice.lang === 'fr-CA' ||
                        voice.lang === 'fr' ||
                        voice.name.toLowerCase().includes('french') ||
                        voice.name.toLowerCase().includes('fran√ßais')
                    );

                    if (frenchVoice) {
                        utterance.voice = frenchVoice;
                        utterance.lang = frenchVoice.lang;
                    } else {
                        // Fallback to setting language without specific voice
                        utterance.lang = 'fr-FR';
                    }

                    utterance.rate = 0.8;
                    utterance.pitch = 1.0;

                    window.speechSynthesis.speak(utterance);
                }
            };

            const startGame = () => {
                const wordList = WORDS[difficulty];
                const selectedWords = wordList.sort(() => 0.5 - Math.random()).slice(0, 10);
                const newGameId = generateGameId(); // NEW

                setGameWords(selectedWords);
                setCurrentQuestion(0);
                setScore(0);
                setUserInput('');
                setFeedback('');
                setCurrentGameId(newGameId); // NEW
                setCurrentGameErrors([]); // NEW
                setGameState('playing');

                // Speak first word after a short delay
                setTimeout(() => {
                    speakWord(selectedWords[0]);
                }, 500);
            };

            const submitAnswer = () => {
                const currentWord = gameWords[currentQuestion];
                const isCorrect = userInput.toLowerCase().trim() === currentWord.toLowerCase();

                let newScore = score;
                if (isCorrect) {
                    newScore = score + 1;
                    setScore(newScore);
                } else {
                    // NEW: Track error
                    const errorEntry = {
                        gameId: currentGameId,
                        timestamp: Date.now(),
                        word: currentWord,
                        userInput: userInput.trim(),
                        difficulty: difficulty,
                        questionNumber: currentQuestion + 1
                    };

                    // Add to current game errors
                    const newGameErrors = [...currentGameErrors, errorEntry];
                    setCurrentGameErrors(newGameErrors);

                    // Add to error history
                    const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                    errorHistory.push(errorEntry);
                    saveToStorage(STORAGE_KEYS.ERROR_HISTORY, errorHistory);
                }

                // Set feedback for previous answer
                const feedbackMessage = isCorrect
                    ? `‚úÖ Correct! Le mot √©tait: ${currentWord}`
                    : `‚ùå Incorrect. Le mot √©tait: ${currentWord} (vous avez √©crit: ${userInput})`;

                setFeedback(feedbackMessage);

                // Immediately transition to next question or finish game
                if (currentQuestion < 9) {
                    setCurrentQuestion(currentQuestion + 1);
                    setUserInput('');
                    // Speak next word immediately
                    setTimeout(() => {
                        speakWord(gameWords[currentQuestion + 1]);
                    }, 100);

                    // Clear feedback after showing it briefly
                    setTimeout(() => {
                        setFeedback('');
                    }, 3000);
                } else {
                    // Clear feedback and finish game after brief delay
                    setTimeout(() => {
                        setFeedback('');
                        finishGame(newScore);
                    }, 2000);
                }
            };

            const finishGame = (finalScore = score) => {
                const gameResult = {
                    id: currentGameId, // NEW: unique identifier
                    date: new Date().toLocaleDateString('fr-FR'),
                    time: new Date().toLocaleTimeString('fr-FR'),
                    score: finalScore,
                    difficulty: difficulty,
                    timestamp: Date.now(),
                    errorCount: currentGameErrors.length // NEW: total errors in this game
                };

                const newLeaderboard = [...leaderboard, gameResult]
                    .sort((a, b) => {
                        // Sort by score first, then by timestamp for ties
                        if (b.score !== a.score) return b.score - a.score;
                        return b.timestamp - a.timestamp;
                    })
                    .slice(0, 10);

                setLeaderboard(newLeaderboard);
                setGameState('finished');
            };

            const resetGame = () => {
                setGameState('start');
                setUserInput('');
                setFeedback('');
                setCurrentGameId(null); // NEW
                setCurrentGameErrors([]); // NEW
                clearStorage(STORAGE_KEYS.GAME_STATE);
            };

            const clearAllData = () => {
                const confirmClear = window.confirm('√ätes-vous s√ªr de vouloir effacer toutes les donn√©es sauvegard√©es?');
                if (confirmClear) {
                    clearStorage(STORAGE_KEYS.LEADERBOARD);
                    clearStorage(STORAGE_KEYS.ERROR_HISTORY); // NEW
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                    clearStorage(STORAGE_KEYS.USER_PREFERENCES);
                    setLeaderboard([]);
                    setDifficulty('facile');
                    alert('Toutes les donn√©es ont √©t√© effac√©es!');
                }
            };

            // NEW: Get errors for a specific game
            const getErrorsForGame = (gameId) => {
                const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                return errorHistory.filter(error => error.gameId === gameId);
            };

            // NEW: Toggle error display
            const toggleErrorDisplay = (gameId) => {
                setExpandedErrors(prev => ({
                    ...prev,
                    [gameId]: !prev[gameId]
                }));
            };

            // NEW: Error display component
            const ErrorDisplay = ({ gameId }) => {
                const errors = getErrorsForGame(gameId);

                if (errors.length === 0) {
                    return (
                        <div className="errors-section">
                            <div className="errors-header">
                                <span className="errors-title">‚ùå Erreurs de cette partie</span>
                                <button
                                    className="close-errors-btn"
                                    onClick={() => toggleErrorDisplay(gameId)}
                                >
                                    √ó
                                </button>
                            </div>
                            <div className="no-errors">Aucune erreur dans cette partie! üéâ</div>
                        </div>
                    );
                }

                return (
                    <div className="errors-section">
                        <div className="errors-header">
                            <span className="errors-title">‚ùå Erreurs de cette partie ({errors.length})</span>
                            <button
                                className="close-errors-btn"
                                onClick={() => toggleErrorDisplay(gameId)}
                            >
                                √ó
                            </button>
                        </div>
                        {errors.map((error, index) => (
                            <div key={index} className="error-item">
                                <div className="error-details">
                                    <div className="error-question">Question {error.questionNumber}/10</div>
                                    <div className="error-comparison">
                                        <span>Correct:</span>
                                        <span className="correct-word">{error.word}</span>
                                        <span>Votre r√©ponse:</span>
                                        <span className="user-word">{error.userInput}</span>
                                        <button
                                            className="replay-error-btn"
                                            onClick={() => speakWord(error.word)}
                                        >
                                            üîä √âcouter
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && userInput.trim()) {
                    submitAnswer();
                }
            };

            if (gameState === 'start') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>üá´üá∑ Test d'Orthographe Fran√ßaise</h1>
                            <div className="start-section">
                                <div>
                                    <label htmlFor="difficulty">Choisissez la difficult√©:</label>
                                    <select
                                        id="difficulty"
                                        value={difficulty}
                                        onChange={(e) => setDifficulty(e.target.value)}
                                    >
                                        <option value="facile">Facile</option>
                                        <option value="moyen">Moyen</option>
                                        <option value="difficile">Difficile</option>
                                    </select>
                                </div>
                                <button onClick={startGame}>Commencer le Jeu</button>
                            </div>

                            {leaderboard.length > 0 && (
                                <div className="leaderboard">
                                    <h3>üèÜ Tableau des Scores</h3>
                                    {leaderboard.map((entry, index) => (
                                        <div key={index} className="leaderboard-entry">
                                            <div className="leaderboard-header">
                                                <div className="leaderboard-info">
                                                    <span>{entry.date} {entry.time}</span>
                                                    <span className={`difficulty-badge ${entry.difficulty}`}>
                                                        {entry.difficulty}
                                                    </span>
                                                    <span><strong>{entry.score}/10</strong></span>
                                                    {entry.errorCount > 0 && (
                                                        <span className="error-count">
                                                            ({entry.errorCount} erreur{entry.errorCount > 1 ? 's' : ''})
                                                        </span>
                                                    )}
                                                </div>
                                                {entry.id && (
                                                    <button
                                                        className="view-errors-btn"
                                                        onClick={() => toggleErrorDisplay(entry.id)}
                                                    >
                                                        üìù Voir erreurs
                                                    </button>
                                                )}
                                            </div>
                                            {expandedErrors[entry.id] && entry.id && (
                                                <ErrorDisplay gameId={entry.id} />
                                            )}
                                        </div>
                                    ))}
                                    <button
                                        className="clear-data-btn"
                                        onClick={clearAllData}
                                    >
                                        Effacer toutes les donn√©es
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (gameState === 'playing') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <div className="score">Score: {score}/{currentQuestion}</div>
                            <div className="question-info">
                                Question {currentQuestion + 1}/10 - Difficult√©: {difficulty}
                                {currentGameErrors.length > 0 && (
                                    <div className="error-count">
                                        {currentGameErrors.length} erreur{currentGameErrors.length > 1 ? 's' : ''} jusqu'ici
                                    </div>
                                )}
                            </div>

                            <div className="game-section">
                                <button
                                    className="replay-btn"
                                    onClick={() => speakWord(gameWords[currentQuestion])}
                                >
                                    üîä R√©p√©ter le mot
                                </button>

                                <div className="input-section">
                                    <input
                                        type="text"
                                        className="word-input"
                                        value={userInput}
                                        onChange={(e) => setUserInput(e.target.value)}
                                        onKeyPress={handleKeyPress}
                                        placeholder="Tapez le mot ici..."
                                        autocapitalize="none"
                                        autocomplete="off"
                                        autocorrect="off"
                                        spellcheck="false"
                                    />
                                    <button
                                        onClick={submitAnswer}
                                        disabled={!userInput.trim()}
                                    >
                                        Valider
                                    </button>
                                </div>

                                <div className="feedback-container">
                                    {feedback && (
                                        <div className={`result ${feedback.includes('Correct') ? 'correct' : 'incorrect'}`}>
                                            {feedback}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'finished') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>üéâ Jeu Termin√©!</h1>
                            <div className="score">Score Final: {score}/10</div>
                            <div className="question-info">
                                Difficult√©: {difficulty}
                                {currentGameErrors.length > 0 && (
                                    <div className="error-count">
                                        {currentGameErrors.length} erreur{currentGameErrors.length > 1 ? 's' : ''} dans cette partie
                                    </div>
                                )}
                            </div>

                            <button onClick={resetGame}>Rejouer</button>

                            {leaderboard.length > 0 && (
                                <div className="leaderboard">
                                    <h3>üèÜ Tableau des Scores</h3>
                                    {leaderboard.map((entry, index) => (
                                        <div key={index} className="leaderboard-entry">
                                            <div className="leaderboard-header">
                                                <div className="leaderboard-info">
                                                    <span>{entry.date} {entry.time}</span>
                                                    <span className={`difficulty-badge ${entry.difficulty}`}>
                                                        {entry.difficulty}
                                                    </span>
                                                    <span><strong>{entry.score}/10</strong></span>
                                                    {entry.errorCount > 0 && (
                                                        <span className="error-count">
                                                            ({entry.errorCount} erreur{entry.errorCount > 1 ? 's' : ''})
                                                        </span>
                                                    )}
                                                </div>
                                                {entry.id && (
                                                    <button
                                                        className="view-errors-btn"
                                                        onClick={() => toggleErrorDisplay(entry.id)}
                                                    >
                                                        üìù Voir erreurs
                                                    </button>
                                                )}
                                            </div>
                                            {expandedErrors[entry.id] && entry.id && (
                                                <ErrorDisplay gameId={entry.id} />
                                            )}
                                        </div>
                                    ))}
                                    <button
                                        className="clear-data-btn"
                                        onClick={clearAllData}
                                    >
                                        Effacer toutes les donn√©es
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }
        }

        ReactDOM.render(<SpellingGame />, document.getElementById('root'));
    </script>
</body>

</html>