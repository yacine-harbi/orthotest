<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test d'Orthographe Fran√ßaise</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Remove crypto-js as we no longer need SHA-1 hashing -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        h1 {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .start-section {
            margin-bottom: 30px;
        }

        select,
        input,
        button {
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .score {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 20px;
        }

        .question-info {
            font-size: 1.2rem;
            color: #4a5568;
            margin-bottom: 20px;
        }

        .input-section {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .word-input {
            min-width: 300px;
            font-size: 18px;
        }

        .replay-btn {
            background: #48bb78;
            padding: 12px 20px;
        }

        .replay-btn:hover {
            background: #38a169;
        }

        .feedback-container {
            height: 80px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result {
            padding: 15px;
            border-radius: 12px;
            font-weight: 600;
            animation: slideInFade 3s ease-in-out;
            width: 100%;
        }

        @keyframes slideInFade {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            10% {
                opacity: 1;
                transform: translateX(0);
            }

            90% {
                opacity: 1;
                transform: translateX(0);
            }

            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        .correct {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }

        .incorrect {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #e53e3e;
        }

        .leaderboard {
            margin-top: 30px;
            text-align: left;
        }

        .leaderboard h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #4a5568;
        }

        .leaderboard-entry {
            background: #f7fafc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .leaderboard-info {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .error-count {
            color: #e53e3e;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .view-errors-btn {
            background: #ed8936;
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .view-errors-btn:hover {
            background: #dd6b20;
            transform: translateY(-1px);
        }

        .view-errors-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .errors-section {
            margin-top: 15px;
            padding: 15px;
            background: #fed7d7;
            border-radius: 8px;
            border: 1px solid #e53e3e;
            animation: expandIn 0.3s ease-out;
        }

        @keyframes expandIn {
            0% {
                opacity: 0;
                max-height: 0;
            }

            100% {
                opacity: 1;
                max-height: 500px;
            }
        }

        .errors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #e53e3e;
            padding-bottom: 8px;
        }

        .errors-title {
            font-weight: 600;
            color: #742a2a;
            font-size: 14px;
        }

        .close-errors-btn {
            background: transparent;
            color: #742a2a;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            margin: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .close-errors-btn:hover {
            background: rgba(116, 42, 42, 0.1);
            transform: none;
            box-shadow: none;
        }

        .error-item {
            margin: 8px 0;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #e53e3e;
        }

        .error-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .error-question {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .error-comparison {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .correct-word {
            color: #22543d;
            font-weight: 600;
            background: #c6f6d5;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .user-word {
            color: #742a2a;
            font-weight: 600;
            background: #fed7d7;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            text-decoration: line-through;
        }

        .replay-error-btn {
            background: #48bb78;
            color: white;
            border: none;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0;
        }

        .replay-error-btn:hover {
            background: #38a169;
            transform: translateY(-1px);
        }

        .difficulty-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .easy {
            background: #c6f6d5;
            color: #22543d;
        }

        .medium {
            background: #feebc8;
            color: #744210;
        }

        .hard {
            background: #fed7d7;
            color: #742a2a;
        }

        .clear-data-btn {
            background: #e53e3e;
            font-size: 12px;
            padding: 8px 16px;
            margin-top: 10px;
        }

        .clear-data-btn:hover {
            background: #c53030;
        }

        .no-errors {
            text-align: center;
            color: #22543d;
            font-style: italic;
            padding: 10px;
        }

        /* Audio Settings Styles */
        .audio-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .audio-section h4 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 150px;
            height: 5px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
            cursor: pointer;
        }

        .audio-test-btn {
            background: #48bb78;
            padding: 10px 15px;
            font-size: 14px;
            text-transform: none;
            letter-spacing: 0;
        }

        .audio-test-btn:hover {
            background: #38a169;
        }

        .audio-test-btn:disabled {
            background: #cbd5e0;
        }

        .audio-status {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }

        /* Loading state */
        .loading {
            text-align: center;
            color: #4a5568;
            font-style: italic;
            padding: 40px;
        }

        .error-message {
            text-align: center;
            color: #e53e3e;
            padding: 40px;
            background: #fed7d7;
            border-radius: 12px;
            margin: 20px 0;
        }

        .audio-error {
            background: #ffeaa7;
            color: #d63031;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // LocalStorage utility functions
        const STORAGE_KEYS = {
            LEADERBOARD: 'french-spelling-leaderboard',
            ERROR_HISTORY: 'french-spelling-error-history',
            GAME_STATE: 'french-spelling-game-state',
            USER_PREFERENCES: 'french-spelling-preferences',
            AUDIO_SETTINGS: 'french-spelling-audio-settings'
        };

        const saveToStorage = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (error) {
                console.warn('Failed to save to localStorage:', error);
            }
        };

        const loadFromStorage = (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
                return defaultValue;
            }
        };

        const clearStorage = (key) => {
            try {
                localStorage.removeItem(key);
            } catch (error) {
                console.warn('Failed to clear localStorage:', error);
            }
        };

        // Generate unique game ID
        const generateGameId = () => {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        };

        // Audio utility functions - Updated to use FLAC files from dictionary
        const getAudioPath = (filename) => {
            return `flac/${filename}`;
        };

        // Hook to load words from JSON file - Updated to use words_dictionary.json
        const useWords = () => {
            const [words, setWords] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            useEffect(() => {
                const loadWords = async () => {
                    try {
                        setLoading(true);
                        const response = await fetch('./words_dictionary.json');
                        
                        if (!response.ok) {
                            throw new Error(`Failed to load words: ${response.status} ${response.statusText}`);
                        }
                        
                        const wordsData = await response.json();
                        setWords(wordsData);
                        setError(null);
                    } catch (err) {
                        console.error('Error loading words:', err);
                        setError(err.message);
                        // Fallback to empty words object
                        setWords({
                            facile: {},
                            moyen: {},
                            difficile: {}
                        });
                    } finally {
                        setLoading(false);
                    }
                };

                loadWords();
            }, []);

            return { words, loading, error };
        };

        function SpellingGame() {
            const [gameState, setGameState] = useState('start');
            const [difficulty, setDifficulty] = useState('facile');
            const [currentQuestion, setCurrentQuestion] = useState(0);
            const [score, setScore] = useState(0);
            const [gameWords, setGameWords] = useState([]);
            const [currentAudioFiles, setCurrentAudioFiles] = useState([]);
            const [userInput, setUserInput] = useState('');
            const [feedback, setFeedback] = useState('');
            const [leaderboard, setLeaderboard] = useState([]);
            const [currentGameId, setCurrentGameId] = useState(null);
            const [currentGameErrors, setCurrentGameErrors] = useState([]);
            const [expandedErrors, setExpandedErrors] = useState({});
            
            // Audio settings states
            const [volume, setVolume] = useState(0.8);
            const [audioError, setAudioError] = useState(null);
            const audioRef = useRef(null);

            // Load words from JSON file
            const { words, loading: wordsLoading, error: wordsError } = useWords();

            // Load audio settings
            useEffect(() => {
                const savedAudioSettings = loadFromStorage(STORAGE_KEYS.AUDIO_SETTINGS, { volume: 0.8 });
                setVolume(savedAudioSettings.volume);
            }, []);

            // Save audio settings
            useEffect(() => {
                saveToStorage(STORAGE_KEYS.AUDIO_SETTINGS, { volume });
            }, [volume]);

            // Load data from localStorage on component mount
            useEffect(() => {
                const savedLeaderboard = loadFromStorage(STORAGE_KEYS.LEADERBOARD, []);
                const savedPreferences = loadFromStorage(STORAGE_KEYS.USER_PREFERENCES, {});

                setLeaderboard(savedLeaderboard);

                // Restore user preferences
                if (savedPreferences.difficulty) {
                    setDifficulty(savedPreferences.difficulty);
                }

                // Check for interrupted game
                const savedGameState = loadFromStorage(STORAGE_KEYS.GAME_STATE);
                if (savedGameState && savedGameState.gameState === 'playing') {
                    // Ask user if they want to continue
                    const continueGame = window.confirm('Vous avez une partie en cours. Voulez-vous la continuer?');
                    if (continueGame) {
                        setGameState(savedGameState.gameState);
                        setDifficulty(savedGameState.difficulty);
                        setCurrentQuestion(savedGameState.currentQuestion);
                        setScore(savedGameState.score);
                        setGameWords(savedGameState.gameWords);
                        setCurrentAudioFiles(savedGameState.currentAudioFiles || []);
                        setCurrentGameId(savedGameState.currentGameId);
                        setCurrentGameErrors(savedGameState.currentGameErrors || []);
                        setUserInput('');
                        setFeedback('');

                        // Speak the current word
                        setTimeout(() => {
                            if (savedGameState.currentAudioFiles && savedGameState.currentAudioFiles[savedGameState.currentQuestion]) {
                                playWordByFilename(savedGameState.currentAudioFiles[savedGameState.currentQuestion]);
                            }
                        }, 500);
                    } else {
                        clearStorage(STORAGE_KEYS.GAME_STATE);
                    }
                }
            }, []);

            // Save leaderboard to localStorage whenever it changes
            useEffect(() => {
                if (leaderboard.length > 0) {
                    saveToStorage(STORAGE_KEYS.LEADERBOARD, leaderboard);
                }
            }, [leaderboard]);

            // Save user preferences
            useEffect(() => {
                saveToStorage(STORAGE_KEYS.USER_PREFERENCES, { difficulty });
            }, [difficulty]);

            // Save game state during gameplay
            useEffect(() => {
                if (gameState === 'playing') {
                    const gameStateData = {
                        gameState,
                        difficulty,
                        currentQuestion,
                        score,
                        gameWords,
                        currentAudioFiles,
                        currentGameId,
                        currentGameErrors
                    };
                    saveToStorage(STORAGE_KEYS.GAME_STATE, gameStateData);
                } else {
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                }
            }, [gameState, difficulty, currentQuestion, score, gameWords, currentAudioFiles, currentGameId, currentGameErrors]);

            const playWordByFilename = (filename) => {
                const audioPath = getAudioPath(filename);
                setAudioError(null);

                // Create a new audio instance
                const audio = new Audio(audioPath);
                audio.volume = volume;

                audio.oncanplaythrough = () => {
                    audio.play().catch(error => {
                        console.error('Error playing audio:', error);
                        setAudioError(`Impossible de jouer le son. Fichier: ${audioPath}`);
                    });
                };

                audio.onerror = () => {
                    console.error('Audio file not found:', audioPath);
                    setAudioError(`Fichier audio introuvable: ${audioPath}`);
                };

                // Update ref for potential cleanup
                audioRef.current = audio;
            };

            const playWord = (word) => {
                // Find the filename for this word in the current difficulty level
                if (!words || !words[difficulty]) return;
                
                const wordEntries = Object.entries(words[difficulty]);
                const entry = wordEntries.find(([filename, w]) => w === word);
                
                if (entry) {
                    playWordByFilename(entry[0]);
                } else {
                    setAudioError(`Fichier audio introuvable pour le mot: ${word}`);
                }
            };

            const testAudio = () => {
                // Test with the first available word in the current difficulty
                if (words && words[difficulty]) {
                    const firstEntry = Object.entries(words[difficulty])[0];
                    if (firstEntry) {
                        playWordByFilename(firstEntry[0]);
                    }
                }
            };

            const startGame = () => {
                if (!words || !words[difficulty] || Object.keys(words[difficulty]).length === 0) {
                    alert('Les mots ne sont pas encore charg√©s ou la difficult√© s√©lectionn√©e est vide. Veuillez r√©essayer.');
                    return;
                }

                const wordEntries = Object.entries(words[difficulty]);
                const shuffledEntries = wordEntries.sort(() => 0.5 - Math.random()).slice(0, 10);
                const selectedWords = shuffledEntries.map(([filename, word]) => word);
                const selectedAudioFiles = shuffledEntries.map(([filename, word]) => filename);
                const newGameId = generateGameId();

                setGameWords(selectedWords);
                setCurrentAudioFiles(selectedAudioFiles);
                setCurrentQuestion(0);
                setScore(0);
                setUserInput('');
                setFeedback('');
                setCurrentGameId(newGameId);
                setCurrentGameErrors([]);
                setGameState('playing');
                setAudioError(null);

                // Speak first word after a short delay
                setTimeout(() => {
                    playWordByFilename(selectedAudioFiles[0]);
                }, 500);
            };

            const submitAnswer = () => {
                const currentWord = gameWords[currentQuestion];
                const isCorrect = userInput.toLowerCase().trim() === currentWord.toLowerCase();

                let newScore = score;
                if (isCorrect) {
                    newScore = score + 1;
                    setScore(newScore);
                } else {
                    // Track error
                    const errorEntry = {
                        gameId: currentGameId,
                        timestamp: Date.now(),
                        word: currentWord,
                        userInput: userInput.trim(),
                        difficulty: difficulty,
                        questionNumber: currentQuestion + 1,
                        audioFile: currentAudioFiles[currentQuestion]
                    };

                    // Add to current game errors
                    const newGameErrors = [...currentGameErrors, errorEntry];
                    setCurrentGameErrors(newGameErrors);

                    // Add to error history
                    const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                    errorHistory.push(errorEntry);
                    saveToStorage(STORAGE_KEYS.ERROR_HISTORY, errorHistory);
                }

                // Set feedback for previous answer
                const feedbackMessage = isCorrect
                    ? `‚úÖ Correct! Le mot √©tait: ${currentWord}`
                    : `‚ùå Incorrect. Le mot √©tait: ${currentWord} (vous avez √©crit: ${userInput})`;

                setFeedback(feedbackMessage);

                // Immediately transition to next question or finish game
                if (currentQuestion < 9) {
                    setCurrentQuestion(currentQuestion + 1);
                    setUserInput('');
                    // Speak next word immediately
                    setTimeout(() => {
                        playWordByFilename(currentAudioFiles[currentQuestion + 1]);
                    }, 100);

                    // Clear feedback after showing it briefly
                    setTimeout(() => {
                        setFeedback('');
                    }, 3000);
                } else {
                    // Clear feedback and finish game after brief delay
                    setTimeout(() => {
                        setFeedback('');
                        finishGame(newScore);
                    }, 2000);
                }
            };

            const finishGame = (finalScore = score) => {
                const gameResult = {
                    id: currentGameId,
                    date: new Date().toLocaleDateString('fr-FR'),
                    time: new Date().toLocaleTimeString('fr-FR'),
                    score: finalScore,
                    difficulty: difficulty,
                    timestamp: Date.now(),
                    errorCount: currentGameErrors.length
                };

                const newLeaderboard = [...leaderboard, gameResult]
                    .sort((a, b) => {
                        // Sort by score first, then by timestamp for ties
                        if (b.score !== a.score) return b.score - a.score;
                        return b.timestamp - a.timestamp;
                    })
                    .slice(0, 10);

                setLeaderboard(newLeaderboard);
                setGameState('finished');
            };

            const resetGame = () => {
                setGameState('start');
                setUserInput('');
                setFeedback('');
                setCurrentGameId(null);
                setCurrentGameErrors([]);
                setCurrentAudioFiles([]);
                setAudioError(null);
                clearStorage(STORAGE_KEYS.GAME_STATE);
            };

            const clearAllData = () => {
                const confirmClear = window.confirm('√ätes-vous s√ªr de vouloir effacer toutes les donn√©es sauvegard√©es?');
                if (confirmClear) {
                    clearStorage(STORAGE_KEYS.LEADERBOARD);
                    clearStorage(STORAGE_KEYS.ERROR_HISTORY);
                    clearStorage(STORAGE_KEYS.GAME_STATE);
                    clearStorage(STORAGE_KEYS.USER_PREFERENCES);
                    clearStorage(STORAGE_KEYS.AUDIO_SETTINGS);
                    setLeaderboard([]);
                    setDifficulty('facile');
                    setVolume(0.8);
                    alert('Toutes les donn√©es ont √©t√© effac√©es!');
                }
            };

            // Get errors for a specific game
            const getErrorsForGame = (gameId) => {
                const errorHistory = loadFromStorage(STORAGE_KEYS.ERROR_HISTORY, []);
                return errorHistory.filter(error => error.gameId === gameId);
            };

            // Toggle error display
            const toggleErrorDisplay = (gameId) => {
                setExpandedErrors(prev => ({
                    ...prev,
                    [gameId]: !prev[gameId]
                }));
            };

            // Error display component
            const ErrorDisplay = ({ gameId }) => {
                const errors = getErrorsForGame(gameId);

                if (errors.length === 0) {
                    return (
                        <div className="errors-section">
                            <div className="errors-header">
                                <span className="errors-title">‚ùå Erreurs de cette partie</span>
                                <button
                                    className="close-errors-btn"
                                    onClick={() => toggleErrorDisplay(gameId)}
                                >
                                    √ó
                                </button>
                            </div>
                            <div className="no-errors">Aucune erreur dans cette partie! üéâ</div>
                        </div>
                    );
                }

                return (
                    <div className="errors-section">
                        <div className="errors-header">
                            <span className="errors-title">‚ùå Erreurs de cette partie ({errors.length})</span>
                            <button
                                className="close-errors-btn"
                                onClick={() => toggleErrorDisplay(gameId)}
                            >
                                √ó
                            </button>
                        </div>
                        {errors.map((error, index) => (
                            <div key={index} className="error-item">
                                <div className="error-details">
                                    <div className="error-question">Question {error.questionNumber}/10</div>
                                    <div className="error-comparison">
                                        <span>Correct:</span>
                                        <span className="correct-word">{error.word}</span>
                                        <span>Votre r√©ponse:</span>
                                        <span className="user-word">{error.userInput}</span>
                                        <button
                                            className="replay-error-btn"
                                            onClick={() => error.audioFile ? playWordByFilename(error.audioFile) : playWord(error.word)}
                                        >
                                            üîä √âcouter
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                );
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && userInput.trim()) {
                    submitAnswer();
                }
            };

            // Audio Settings Component
            const AudioSettings = () => {
                return (
                    <div className="audio-section">
                        <h4>üîä Param√®tres Audio</h4>
                        <div className="audio-controls">
                            <div className="volume-control">
                                <span>Volume:</span>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.1"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    className="volume-slider"
                                />
                                <span>{Math.round(volume * 100)}%</span>
                            </div>
                            <button
                                className="audio-test-btn"
                                onClick={testAudio}
                            >
                                üîä Test Audio
                            </button>
                        </div>
                        {audioError && (
                            <div className="audio-error">
                                {audioError}
                            </div>
                        )}
                        <div className="audio-status">
                            Les fichiers audio FLAC sont charg√©s depuis le dossier flac/
                        </div>
                    </div>
                );
            };

            // Show loading state while words are being loaded
            if (wordsLoading) {
                return (
                    <div className="container">
                        <div className="game-card">
                            <div className="loading">
                                Chargement des mots...
                            </div>
                        </div>
                    </div>
                );
            }

            // Show error state if words failed to load
            if (wordsError) {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>Test d'Orthographe</h1>
                            <div className="error-message">
                                <h3>Erreur de chargement</h3>
                                <p>Impossible de charger les mots du jeu.</p>
                                <p>Erreur: {wordsError}</p>
                                <p>Assurez-vous que le fichier words_dictionary.json est pr√©sent dans le r√©pertoire du jeu.</p>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'start') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>üéØ Test d'Orthographe Fran√ßaise</h1>
                            <div className="start-section">
                                <div>
                                    <label htmlFor="difficulty">Choisissez la difficult√© :</label>
                                    <select
                                        id="difficulty"
                                        value={difficulty}
                                        onChange={(e) => setDifficulty(e.target.value)}
                                    >
                                        <option value="facile">üòä Facile</option>
                                        <option value="moyen">üòê Moyen</option>
                                        <option value="difficile">üò§ Difficile</option>
                                    </select>
                                </div>
                                <button onClick={startGame}>
                                    üöÄ Commencer le jeu
                                </button>
                            </div>

                            <AudioSettings />

                            {leaderboard.length > 0 && (
                                <div className="leaderboard">
                                    <h3>üèÜ Meilleures Performances</h3>
                                    {leaderboard.map((entry, index) => (
                                        <div key={entry.id} className="leaderboard-entry">
                                            <div className="leaderboard-header">
                                                <div className="leaderboard-info">
                                                    <span>#{index + 1}</span>
                                                    <span className={`difficulty-badge ${entry.difficulty === 'facile' ? 'easy' : entry.difficulty === 'moyen' ? 'medium' : 'hard'}`}>
                                                        {entry.difficulty}
                                                    </span>
                                                    <strong>{entry.score}/10</strong>
                                                    <span>{entry.date} √† {entry.time}</span>
                                                    {entry.errorCount > 0 && (
                                                        <span className="error-count">
                                                            {entry.errorCount} erreur{entry.errorCount > 1 ? 's' : ''}
                                                        </span>
                                                    )}
                                                </div>
                                                {entry.errorCount > 0 && (
                                                    <button
                                                        className="view-errors-btn"
                                                        onClick={() => toggleErrorDisplay(entry.id)}
                                                    >
                                                        {expandedErrors[entry.id] ? 'Masquer' : 'Voir'} erreurs
                                                    </button>
                                                )}
                                            </div>
                                            {expandedErrors[entry.id] && <ErrorDisplay gameId={entry.id} />}
                                        </div>
                                    ))}
                                    <button className="clear-data-btn" onClick={clearAllData}>
                                        üóëÔ∏è Effacer toutes les donn√©es
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (gameState === 'playing') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>üéØ Test d'Orthographe</h1>
                            <div className="game-section">
                                <div className="score">Score: {score}/10</div>
                                <div className="question-info">
                                    Question {currentQuestion + 1}/10
                                    <div className={`difficulty-badge ${difficulty === 'facile' ? 'easy' : difficulty === 'moyen' ? 'medium' : 'hard'}`}>
                                        {difficulty}
                                    </div>
                                </div>

                                <button
                                    className="replay-btn"
                                    onClick={() => currentAudioFiles[currentQuestion] && playWordByFilename(currentAudioFiles[currentQuestion])}
                                >
                                    üîä R√©p√©ter le mot
                                </button>

                                <div className="input-section">
                                    <input
                                        type="text"
                                        className="word-input"
                                        value={userInput}
                                        onChange={(e) => setUserInput(e.target.value)}
                                        onKeyPress={handleKeyPress}
                                        placeholder="Tapez le mot que vous entendez..."
                                        autoFocus
                                    />
                                    <button
                                        onClick={submitAnswer}
                                        disabled={!userInput.trim()}
                                    >
                                        ‚úì Valider
                                    </button>
                                </div>

                                <div className="feedback-container">
                                    {feedback && (
                                        <div className={`result ${feedback.includes('‚úÖ') ? 'correct' : 'incorrect'}`}>
                                            {feedback}
                                        </div>
                                    )}
                                </div>

                                {audioError && (
                                    <div className="audio-error">
                                        {audioError}
                                    </div>
                                )}

                                <AudioSettings />
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'finished') {
                return (
                    <div className="container">
                        <div className="game-card">
                            <h1>üéâ Partie termin√©e!</h1>
                            <div className="game-section">
                                <div className="score">Score final: {score}/10</div>
                                <div className={`difficulty-badge ${difficulty === 'facile' ? 'easy' : difficulty === 'moyen' ? 'medium' : 'hard'}`}>
                                    {difficulty}
                                </div>
                                
                                {currentGameErrors.length > 0 && (
                                    <div style={{ margin: '20px 0' }}>
                                        <button
                                            className="view-errors-btn"
                                            onClick={() => toggleErrorDisplay(currentGameId)}
                                        >
                                            {expandedErrors[currentGameId] ? 'Masquer' : 'Voir'} vos erreurs ({currentGameErrors.length})
                                        </button>
                                        {expandedErrors[currentGameId] && <ErrorDisplay gameId={currentGameId} />}
                                    </div>
                                )}

                                <button onClick={resetGame}>
                                    üîÑ Nouvelle partie
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SpellingGame />);
    </script>
</body>

</html>